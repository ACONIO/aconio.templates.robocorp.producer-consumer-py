"""Interact with BMD using the CLI."""

import os
import functools
import subprocess

from robocorp import log

from aconio.bmd._config import config, ExecutableType


class BMDExecutable:
    """Represent a BMD executable."""

    _ntcs_dir: str
    """Path to the BMD directory."""

    _exec_type: ExecutableType
    """BMD executable type."""

    def __init__(self, ntcs_dir: str, exec_type: ExecutableType) -> None:
        if ntcs_dir:
            self._ntcs_dir = ntcs_dir
        else:
            raise ValueError(
                "'ntcs_dir' is required to determine correct BMD executable! "
                "Did you set the module configuration?"
            )

        if exec_type:
            self._exec_type = exec_type
        else:
            raise ValueError(
                "'exec_type' is required to determine correct BMD executable! "
                "Did you set the module configuration?"
            )

    @property
    def executable_path(self) -> str:
        """Full path to the BMD executable."""
        return os.path.join(self._ntcs_dir, self._exec_type.value)

    def _bmd_param(self, key: str, value: str | None = None) -> str:
        """Return the string representation of a BMD CLI parameter.

        Note: CLI paramters that don't require a value can be generated by
        passing only the parameter key (e.g. `/FINISH`).
        """
        if value:
            return f"/{key}={value}"
        else:
            return f"/{key}"

    def start(self) -> None:
        """Start the BMD executable, which opens the BMD UI."""
        subprocess.run(self.executable_path, check=True)

    def run_macro(self, macro_id: str, params: dict[str, str]) -> None:
        """Execute a BMD macro via the CLI.

        Args:
            macro_id:
                The `FOR_FORMELNR` of the BMD macro. Can be found in BMD under
                `[TOOLS - Makros]` in the `Formel/Makro-Nr` column.
            params:
                Additional parameters for the CLI call.
        """
        params["FOR_FORMELNR"] = macro_id
        self.run(
            function_name="MCS_MACRO_EXECUTE",
            params=params,
        )

    def run(
        self,
        function_name: str,
        params: dict[str, str] = None,
        messages: bool = True,
    ) -> None:
        """Execute a BMD function with the configured BMD executable.

        Note: When using executable type `EXEC`, a BMD window must be visible
        on screen (started via "BMDExec.exe"). Also, possible pop-ups appearing
        after the CLI call must be handeled by the user!

        Args:
            function_name:
                Name of the BMD function to be executed.
            params:
                Additional parameters for the CLI call.
            messages:
                If false, `/NOMESSAGES=1` will be passed to the CLI call, which
                prevents any pop-ups from showing up after the import. Defaults
                to `True`.
        """

        cmd = [
            self.executable_path,
            self._bmd_param("PRODUCT", "BMDNTCS"),
            self._bmd_param("FUNC", function_name),
        ]

        if params:
            for k, v in params.items():
                cmd.append(self._bmd_param(k, v))

        if messages:
            cmd.append(self._bmd_param("NOMESSAGES", "0"))
        else:
            cmd.append(self._bmd_param("NOMESSAGES", "1"))

        # If exec type `NTCS` is used, a new BMDNTCS instance is created
        # for every command. Thus, pass the '/FINISH' parameter to
        # immediately close the instance after the command has finished.
        if self._exec_type == ExecutableType.NTCS:
            cmd.append(self._bmd_param("FINISH"))

        cmd_str = " ".join(cmd)
        log.info(f"Running BMD CLI command: {cmd_str}")
        subprocess.run(rf"{cmd_str}", check=True)


@functools.lru_cache
def ntcs_cli() -> BMDExecutable:
    return BMDExecutable(config().ntcs_dir, config().ntcs_exec_type)
